<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Physics - Squares Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #f0e8f5;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    
    #world {
      position: relative;
      width: 800px;
      height: 600px;
      background: #ffffff;
      border: 2px solid #6b4c7a;
      overflow: visible; /* Changed from hidden to visible to prevent clipping */
    }
    
    .square {
      position: absolute;
      width: 30px;
      height: 30px;
      background: #8b6fa0;
      border: 1px solid #6b4c7a;
      box-shadow: 0 2px 4px rgba(107, 76, 122, 0.2);
    }
    
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #6b4c7a;
      font-size: 12px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 5px;
      border: 1px solid #6b4c7a;
    }
  </style>
</head>
<body>
  <div id="world">
    <div class="controls">
      <div>Click to add squares</div>
      <div>Drag to move them</div>
    </div>
  </div>

  <script type="module">
    import { World, Body } from '/dist/index.js';
    
    const worldElement = document.getElementById('world');
    const world = new World(worldElement, {
      gravity: 300,
      friction: 0.97, // Slightly more friction to help settle
      restitution: 0.4 // Lower restitution to reduce bouncing
    });
    
    const bodies = [];
    let draggedBody = null;
    let isDragging = false;
    let dragStartTime = null;
    let wasDragging = false; // Flag to prevent click after drag
    let lastDragX = null; // Track last drag position for velocity calculation
    let lastDragY = null;
    let dragVelocities = []; // Store recent velocities for smoothing
    
    // Create initial squares
    function createSquare(x, y) {
      const square = document.createElement('div');
      square.className = 'square';
      square.style.left = x + 'px';
      square.style.top = y + 'px';
      worldElement.appendChild(square);
      
      const body = new Body(square, world, {
        mass: 1,
        radius: 15,
        restitution: 0.4 // Lower restitution to reduce bouncing
      });
      
      world.registerBody(body);
      bodies.push(body);
      
      return body;
    }
    
    // Create a grid of squares
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < 8; j++) {
        createSquare(50 + i * 70, 50 + j * 60);
      }
    }
    
    world.start();
    
    // Mouse drag interaction
    worldElement.addEventListener('mousedown', (e) => {
      const rect = worldElement.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      
      console.log(`[Drag] mousedown at (${mx.toFixed(1)}, ${my.toFixed(1)})`);
      
      // Find closest body
      let closestBody = null;
      let minDist = Infinity;
      const candidates = [];
      
      bodies.forEach((body, index) => {
        // Skip bodies that are currently being dragged
        if (body.isDragged) {
          candidates.push({ index, dist: Infinity, pos: body.getWorldPosition(), body, skipped: 'dragged' });
          return;
        }
        
        const pos = body.getWorldPosition();
        const dx = pos.x - mx;
        const dy = pos.y - my;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        candidates.push({ index, dist, pos, body });
        
        if (dist < 30 && dist < minDist) {
          minDist = dist;
          closestBody = body;
        }
      });
      
      // Log all candidates sorted by distance
      candidates.sort((a, b) => a.dist - b.dist);
      console.log(`[Drag] Candidates (top 5):`);
      candidates.slice(0, 5).forEach(c => {
        console.log(`  Square ${c.index}: dist=${c.dist.toFixed(1)}, pos=(${c.pos.x.toFixed(1)}, ${c.pos.y.toFixed(1)}), center dist=${c.dist.toFixed(1)}`);
      });
      
      if (closestBody) {
        const selectedIndex = bodies.indexOf(closestBody);
        const selectedPos = closestBody.getWorldPosition();
        console.log(`[Drag] Selected square ${selectedIndex} at (${selectedPos.x.toFixed(1)}, ${selectedPos.y.toFixed(1)}), distance=${minDist.toFixed(1)}`);
        
        draggedBody = closestBody;
        isDragging = true;
        dragStartTime = Date.now();
        draggedBody.isDragged = true;
        
        // Initialize drag tracking
        lastDragX = mx - draggedBody.originX;
        lastDragY = my - draggedBody.originY;
        dragVelocities = [];
      } else {
        console.log(`[Drag] No square found within 30px`);
      }
    });
    
    worldElement.addEventListener('mousemove', (e) => {
      if (isDragging && draggedBody) {
        const rect = worldElement.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        
        // Directly set position to follow mouse
        const targetX = mx - draggedBody.originX;
        const targetY = my - draggedBody.originY;
        
        // Calculate drag velocity (position change per frame)
        if (lastDragX !== null && lastDragY !== null) {
          const vx = targetX - lastDragX;
          const vy = targetY - lastDragY;
          
          // Store velocity for momentum calculation (keep last 5 frames)
          dragVelocities.push({ vx, vy });
          if (dragVelocities.length > 5) {
            dragVelocities.shift();
          }
        }
        
        draggedBody.x = targetX;
        draggedBody.y = targetY;
        draggedBody.prevX = targetX;
        draggedBody.prevY = targetY;
        
        // Update last drag position
        lastDragX = targetX;
        lastDragY = targetY;
        
        // Render immediately to show the dragged body
        draggedBody.render();
      }
    });
    
    worldElement.addEventListener('mouseup', (e) => {
      if (isDragging && draggedBody) {
        // Calculate average velocity from recent drag movements for flinging
        let avgVx = 0;
        let avgVy = 0;
        if (dragVelocities.length > 0) {
          // Use weighted average (more recent movements have more weight)
          let totalWeight = 0;
          dragVelocities.forEach((vel, index) => {
            const weight = index + 1; // More recent = higher weight
            avgVx += vel.vx * weight;
            avgVy += vel.vy * weight;
            totalWeight += weight;
          });
          avgVx /= totalWeight;
          avgVy /= totalWeight;
          
          // Apply momentum: set prevX/prevY to create velocity in drag direction
          // In Verlet: velocity = (x - prevX), so prevX = x - velocity
          // Use moderate scale to allow flinging while still letting gravity accelerate
          const momentumScale = 0.8; // Moderate momentum for flinging
          draggedBody.prevX = draggedBody.x - avgVx * momentumScale;
          draggedBody.prevY = draggedBody.y - avgVy * momentumScale;
        } else {
          // No velocity tracked, release with zero initial velocity
          draggedBody.prevX = draggedBody.x;
          draggedBody.prevY = draggedBody.y;
        }
        
        draggedBody.isDragged = false;
        wasDragging = true;
        // Clear the flag after a short delay to prevent click event
        setTimeout(() => {
          wasDragging = false;
        }, 100);
      }
      isDragging = false;
      draggedBody = null;
      dragStartTime = null;
      lastDragX = null;
      lastDragY = null;
      dragVelocities = [];
    });
    
    // Click to add squares - use a flag to prevent click after drag
    worldElement.addEventListener('click', (e) => {
      // Prevent click from firing immediately after drag ends
      if (wasDragging) {
        wasDragging = false;
        return;
      }
      
      if (!isDragging) {
        const rect = worldElement.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        createSquare(x - 15, y - 15);
      }
    });
  </script>
</body>
</html>

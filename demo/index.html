<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM Physics Engine</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #f5f5f0;
      font-family: Georgia, serif;
      overflow: hidden;
    }
    
    #world {
      position: relative;
      width: 800px;
      height: 600px;
      margin: 40px auto;
      background: #fafaf8;
      border: 2px solid #2c3e50;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .container {
      padding: 40px;
    }
    
    .text {
      font-size: 18px;
      line-height: 1.8;
      color: #2c3e50;
      display: inline-block;
    }
    
    .text span {
      display: inline-block;
      margin: 0;
      padding: 0;
    }
    
    .physics-active .text span {
      position: relative;
    }
  </style>
</head>
<body>
  <div id="world">
    <div class="container">
      <div class="text">
        Two roads diverged in a yellow wood,<br>
        And sorry I could not travel both<br>
        And be one traveler, long I stood<br>
        And looked down one as far as I could<br>
        To where it bent in the undergrowth;
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // PHYSICS ENGINE
    // ============================================================================
    
    class Body {
      constructor(element, world, config = {}) {
        this.element = element;
        this.world = world;
        
        // Capture original parent
        this.originalParent = element.parentElement;
        
        // Get world and element positions
        const worldRect = world.container.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();
        
        // Calculate origin in world space
        this.originX = elemRect.left - worldRect.left;
        this.originY = elemRect.top - worldRect.top;
        
        // Physics state (relative to origin)
        this.x = 0;
        this.y = 0;
        this.prevX = 0;
        this.prevY = 0;
        this.ax = 0;
        this.ay = 0;
        
        // Properties
        this.mass = config.mass || 1;
        this.radius = config.radius || Math.max(elemRect.width, elemRect.height) / 2;
        this.restitution = config.restitution !== undefined ? config.restitution : null;
        this.friction = config.friction !== undefined ? config.friction : null;
        this.isStatic = config.isStatic || false;
        this.enabled = true;
        
        // Ensure can be transformed
        const display = getComputedStyle(element).display;
        if (display === 'inline') {
          element.style.display = 'inline-block';
        }
      }
      
      applyForce(fx, fy) {
        if (this.isStatic || !this.enabled) return;
        this.ax += fx / this.mass;
        this.ay += fy / this.mass;
      }
      
      integrate(dt, world) {
        if (this.isStatic || !this.enabled) return;
        
        this.ay += world.gravity;
        
        const friction = this.friction !== null ? this.friction : world.friction;
        const vx = (this.x - this.prevX) * friction;
        const vy = (this.y - this.prevY) * friction;
        
        this.prevX = this.x;
        this.prevY = this.y;
        
        this.x += vx + this.ax * dt * dt;
        this.y += vy + this.ay * dt * dt;
        
        this.ax = 0;
        this.ay = 0;
      }
      
      getWorldPosition() {
        return {
          x: this.originX + this.x,
          y: this.originY + this.y
        };
      }
      
      render() {
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
      }
    }
    
    class World {
      constructor(container, config = {}) {
        this.container = container;
        this.bodies = [];
        
        this.gravity = config.gravity !== undefined ? config.gravity : 980;
        this.friction = config.friction !== undefined ? config.friction : 0.99;
        this.restitution = config.restitution !== undefined ? config.restitution : 0.8;
        this.timeStep = config.timeStep || 1/60;
        
        const rect = container.getBoundingClientRect();
        this.bounds = config.bounds || {
          x: 0,
          y: 0,
          width: rect.width,
          height: rect.height
        };
        
        this.running = false;
        this.lastTime = 0;
        this.accumulator = 0;
      }
      
      registerBody(body) {
        if (!this.bodies.includes(body)) {
          this.bodies.push(body);
        }
      }
      
      unregisterBody(body) {
        const index = this.bodies.indexOf(body);
        if (index > -1) {
          this.bodies.splice(index, 1);
        }
      }
      
      start() {
        if (this.running) return;
        this.running = true;
        this.lastTime = performance.now();
        this.accumulator = 0;
        this.loop(this.lastTime);
      }
      
      stop() {
        this.running = false;
      }
      
      loop = (time) => {
        if (!this.running) return;
        
        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        this.accumulator += deltaTime;
        
        while (this.accumulator >= this.timeStep * 1000) {
          this.step();
          this.accumulator -= this.timeStep * 1000;
        }
        
        for (const body of this.bodies) {
          body.render();
        }
        
        requestAnimationFrame(this.loop);
      }
      
      step() {
        // Integrate
        for (const body of this.bodies) {
          body.integrate(this.timeStep, this);
        }
        
        // Collisions
        for (let i = 0; i < this.bodies.length; i++) {
          for (let j = i + 1; j < this.bodies.length; j++) {
            this.resolveCollision(this.bodies[i], this.bodies[j]);
          }
        }
        
        // Bounds
        for (const body of this.bodies) {
          this.constrainToBounds(body);
        }
      }
      
      resolveCollision(a, b) {
        const posA = a.getWorldPosition();
        const posB = b.getWorldPosition();
        
        const dx = posB.x - posA.x;
        const dy = posB.y - posA.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = a.radius + b.radius;
        
        if (dist >= minDist || dist === 0) return;
        
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        
        const totalMass = a.mass + b.mass;
        const aRatio = b.mass / totalMass;
        const bRatio = a.mass / totalMass;
        
        if (!a.isStatic) {
          a.x -= nx * overlap * aRatio;
          a.y -= ny * overlap * aRatio;
        }
        if (!b.isStatic) {
          b.x += nx * overlap * bRatio;
          b.y += ny * overlap * bRatio;
        }
        
        const restitution = Math.min(
          a.restitution !== null ? a.restitution : this.restitution,
          b.restitution !== null ? b.restitution : this.restitution
        );
        
        const aVx = (a.x - a.prevX) * restitution;
        const aVy = (a.y - a.prevY) * restitution;
        const bVx = (b.x - b.prevX) * restitution;
        const bVy = (b.y - b.prevY) * restitution;
        
        if (!a.isStatic) {
          a.prevX = a.x - bVx;
          a.prevY = a.y - bVy;
        }
        if (!b.isStatic) {
          b.prevX = b.x - aVx;
          b.prevY = b.y - aVy;
        }
      }
      
      constrainToBounds(body) {
        if (body.isStatic || !body.enabled) return;
        
        const restitution = body.restitution !== null ? body.restitution : this.restitution;
        const pos = body.getWorldPosition();
        
        // Bottom
        if (pos.y + body.radius > this.bounds.height) {
          const diff = (this.bounds.height - body.radius) - pos.y;
          body.y += diff;
          body.prevY = body.y + (body.y - body.prevY) * restitution;
        }
        
        // Top
        if (pos.y - body.radius < 0) {
          const diff = body.radius - pos.y;
          body.y += diff;
          body.prevY = body.y - (body.y - body.prevY) * restitution;
        }
        
        // Left
        if (pos.x - body.radius < 0) {
          const diff = body.radius - pos.x;
          body.x += diff;
          body.prevX = body.x - (body.x - body.prevX) * restitution;
        }
        
        // Right
        if (pos.x + body.radius > this.bounds.width) {
          const diff = (this.bounds.width - body.radius) - pos.x;
          body.x += diff;
          body.prevX = body.x + (body.x - body.prevX) * restitution;
        }
      }
    }
    
    // ============================================================================
    // DEMO
    // ============================================================================
    
    const worldElement = document.getElementById('world');
    const textElement = document.querySelector('.text');
    
    // Wrap each character in a span on first hover
    let initialized = false;
    let world = null;
    let bodies = [];
    
    function initializePhysics() {
      if (initialized) return;
      initialized = true;
      
      // Wrap each character
      const text = textElement.innerHTML;
      const wrapped = text.split('').map(char => {
        if (char === '<') {
          // Handle <br> tags
          let tag = '';
          let i = 0;
          while (text[text.indexOf(char) + i] !== '>' && i < 10) {
            tag += text[text.indexOf(char) + i];
            i++;
          }
          tag += '>';
          return tag;
        }
        if (char === ' ') {
          return '<span class="space"> </span>';
        }
        if (char === '\n') {
          return '';
        }
        return `<span>${char}</span>`;
      }).join('');
      
      textElement.innerHTML = wrapped;
      
      // Initialize world
      world = new World(worldElement, {
        gravity: 400,
        friction: 0.97,
        restitution: 0.5
      });
      
      // Register all character spans as bodies
      const spans = textElement.querySelectorAll('span:not(.space)');
      
      spans.forEach((span) => {
        const body = new Body(span, world, {
          mass: 1,
          radius: 8,
          restitution: 0.6
        });
        world.registerBody(body);
        bodies.push(body);
      });
      
      worldElement.classList.add('physics-active');
      world.start();
    }
    
    // Mouse interaction - only on text hover
    textElement.addEventListener('mousemove', (e) => {
      if (!initialized) {
        initializePhysics();
      }
      
      const rect = worldElement.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      
      bodies.forEach(body => {
        const pos = body.getWorldPosition();
        const dx = pos.x - mx;
        const dy = pos.y - my;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 80 && dist > 0) {
          const force = (80 - dist) * 80;
          body.applyForce(
            (dx / dist) * force,
            (dy / dist) * force
          );
        }
      });
    });
  </script>
</body>
</html>
